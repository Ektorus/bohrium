#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
/*
This file is part of cphVB and copyright (c) 2012 the cphVB team:
http://cphvb.bitbucket.org

cphVB is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

cphVB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with cphVB. 

If not, see <http://www.gnu.org/licenses/>.
*/
#include <cphvb.h>
#include <cphvb_compute.h>
#include "functors.hpp"
#include "iterator2.hpp"
#include "cphvb_compute_iterator2.hpp"
#include <complex>

cphvb_computeloop_iterator2 cphvb_compute_iterator2_get( cphvb_instruction *instr, cphvb_index ndim ) {

    // Poly contains a unique value, pairing an opcode with its function signature.
    // All in one nicely switchable value.
    long int poly;
 
    if (cphvb_operands(instr->opcode) == 3) {   // Three operands

        if (cphvb_is_constant(instr->operand[1])) {             // First operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(instr->operand[2]->type << 16) \
                +(1 << 17);

        } else if (cphvb_is_constant(instr->operand[2])) {      // Second operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->constant.type << 16) \
                +(1 << 18);

        } else {                                                // No constant operand
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->operand[2]->type << 16);
        }

    } else {                                    // Two operands

        if (cphvb_is_constant(instr->operand[1])) {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(1 << 17);
        } else {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12);
        }
    }
    
    switch(ndim) {
    	%for $dim in range(16)
		case ${dim+1}:
			switch(poly) {
		
				%for $case in $data
				%if $case.nop == 2
				case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12):
					return &traverse_it2_aa_${dim+1}d<${case.ftypes}, ${case.fname}_functor<${case.ftypes} >, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_dense2_iterator_next, cphvb_dense2_iterator >;
				case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (1 << 17):
					return &traverse_it2_aa_${dim+1}d<${case.ftypes}, ${case.fname}_functor<${case.ftypes} >, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_noop_iterator_next, cphvb_const2_iterator >;
				%else
				case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16):
					return &traverse_it2_aaa_${dim+1}d<${case.ftypes}, ${case.fname}_functor<${case.ftypes} >, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_dense2_iterator_next, cphvb_dense2_iterator >;
				case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 18):
					return &traverse_it2_aaa_${dim+1}d<${case.ftypes}, ${case.fname}_functor<${case.ftypes} >, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_noop_iterator_next, cphvb_const2_iterator >;
				case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 17):
					return &traverse_it2_aaa_${dim+1}d<${case.ftypes}, ${case.fname}_functor<${case.ftypes} >, cphvb_dense2_iterator_next, cphvb_dense2_iterator, cphvb_noop_iterator_next, cphvb_const2_iterator, cphvb_dense2_iterator_next, cphvb_dense2_iterator >;
				%end if
				%end for
		
				default:
					return NULL;
		
			}
		%end for
		
		default:
			return NULL;
    }

}
