#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
/*
This file is part of cphVB and copyright (c) 2012 the cphVB team:
http://cphvb.bitbucket.org

cphVB is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

cphVB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with cphVB. 

If not, see <http://www.gnu.org/licenses/>.
*/
 
#include <cphvb.h>
#include <assert.h>

typedef char BYTE;

#define INNER_LOOP_AAA(opcode_func, fulls, remainder, d0, d1, d2, stride0, stride1, stride2) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
		d0 += stride0; \
		d1 += stride1; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
		d0 += stride0; \
		d1 += stride1; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
		d0 += stride0; \
		d1 += stride1; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
		d0 += stride0; \
		d1 += stride1; \
		d2 += stride2; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
			d0 += stride0; \
			d1 += stride1; \
			d2 += stride2; \
		case 2: \
			opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
			d0 += stride0; \
			d1 += stride1; \
			d2 += stride2; \
		case 1: \
			opcode_func( ((T0*)d0), ((T1*)d1), ((T2*)d2) ); \
			d0 += stride0; \
			d1 += stride1; \
			d2 += stride2; \
	} \
}

#define INNER_LOOP_AAC(opcode_func, fulls, remainder, d0, d1, c, stride0, stride1) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( ((T0*)d0), ((T1*)d1), c ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1), c ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1), c ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1), c ); \
		d0 += stride0; \
		d1 += stride1; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( ((T0*)d0), ((T1*)d1), c ); \
			d0 += stride0; \
			d1 += stride1; \
		case 2: \
			opcode_func( ((T0*)d0), ((T1*)d1), c ); \
			d0 += stride0; \
			d1 += stride1; \
		case 1: \
			opcode_func( ((T0*)d0), ((T1*)d1), c ); \
			d0 += stride0; \
			d1 += stride1; \
	} \
}

#define INNER_LOOP_ACA(opcode_func, fulls, remainder, d0, c, d2, stride0, stride2) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
		d0 += stride0; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
		d0 += stride0; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
		d0 += stride0; \
		d2 += stride2; \
		opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
		d0 += stride0; \
		d2 += stride2; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
			d0 += stride0; \
			d2 += stride2; \
		case 2: \
			opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
			d0 += stride0; \
			d2 += stride2; \
		case 1: \
			opcode_func( ((T0*)d0), c, ((T2*)d2) ); \
			d0 += stride0; \
			d2 += stride2; \
	} \
}

#define INNER_LOOP_SSA(opcode_func, fulls, remainder, d1, stride1, scalar) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( (scalar), (scalar), ((T1*)d1) ); \
		d1 += stride1; \
		opcode_func( (scalar), (scalar), ((T1*)d1) ); \
		d1 += stride1; \
		opcode_func( (scalar), (scalar), ((T1*)d1) ); \
		d1 += stride1; \
		opcode_func( (scalar), (scalar), ((T1*)d1) ); \
		d1 += stride1; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( (scalar), (scalar), ((T1*)d1) ); \
			d1 += stride1; \
		case 2: \
			opcode_func( (scalar), (scalar), ((T1*)d1) ); \
			d1 += stride1; \
		case 1: \
			opcode_func( (scalar), (scalar), ((T1*)d1) ); \
			d1 += stride1; \
	} \
}

#define INNER_LOOP_AA(opcode_func, fulls, remainder, d0, d1, stride0, stride1) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( ((T0*)d0), ((T1*)d1) ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1) ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1) ); \
		d0 += stride0; \
		d1 += stride1; \
		opcode_func( ((T0*)d0), ((T1*)d1) ); \
		d0 += stride0; \
		d1 += stride1; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( ((T0*)d0), ((T1*)d1) ); \
			d0 += stride0; \
			d1 += stride1; \
		case 2: \
			opcode_func( ((T0*)d0), ((T1*)d1) ); \
			d0 += stride0; \
			d1 += stride1; \
		case 1: \
			opcode_func( ((T0*)d0), ((T1*)d1) ); \
			d0 += stride0; \
			d1 += stride1; \
	} \
}

#define INNER_LOOP_AC(opcode_func, fulls, remainder, d0, c, stride0) \
{ \
	cphvb_index loop_i; \
	for (loop_i = 0; loop_i < fulls; loop_i++) \
	{ \
		opcode_func( ((T0*)d0), (c) ); \
		d0 += stride0; \
		opcode_func( ((T0*)d0), (c) ); \
		d0 += stride0; \
		opcode_func( ((T0*)d0), (c) ); \
		d0 += stride0; \
		opcode_func( ((T0*)d0), (c) ); \
		d0 += stride0; \
	} \
 \
	switch (remainder) \
	{ \
		case 3: \
			opcode_func( ((T0*)d0), (c) ); \
			d0 += stride0; \
		case 2: \
			opcode_func( ((T0*)d0), (c) ); \
			d0 += stride0; \
		case 1: \
			opcode_func( ((T0*)d0), (c) ); \
			d0 += stride0; \
	} \
}

%for $traverse in $data
/**
 *  An optimized implementation of executing an instruction.
 *
 *  @param instr The instruction to execute
 *  @param state State of the iteration
 *  @param nelements the number of elements on which the instruction should be applied.
 *  @return This function always returns CPHVB_SUCCESS unless it raises an exception with assert.
 */
template <${traverse.tsig}, typename Instr>
cphvb_error traverse_coord_${traverse.sig}( cphvb_instruction *instr, cphvb_tstate* state, cphvb_cstate* cstate ) {

    Instr opcode_func;                        	// Element-wise functor-pointer

    cphvb_index i, j;                        	// Traversal variables

    BYTE* d0 = (BYTE*)cstate->start[0];			// Pointers to start of data elements
    %for $op_n, $op_t in $traverse.ops[1:]
    %if $op_t == 'a'
    BYTE* d${op_n} = (BYTE*)cstate->start[${op_n}];
    %end if
    %end for

    %for $op_n, $op_t in $traverse.ops[1:]
    %if $op_t == 'c'
    T${op_n}* c = (T${op_n}*) &(instr->constant.value);
    %end if
    %end for

	cphvb_index elements = cstate->elements;

	if (state->ndim == 1)
	{
		// Simple 1D loop
		cphvb_index stride0 = state->stride[0][0];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index stride${op_n} = state->stride[${op_n}][0];
        %end if
        %end for
		
		cphvb_index remainder = elements % 4;
		cphvb_index fulls = elements / 4;

		//Macro magic time!
        %echo '        INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
        %for $op_n, $op_t in $traverse.ops
        %if $op_t == 'a'
        %echo 'd'+str($op_n)+', '
        %else
        %echo 'c, '
        %end if
        %end for
        %set sep=''
        %for $op_n, $op_t in $traverse.ops
        %if $op_t == 'a'
        %echo $sep+"stride"+str($op_n)
        %set sep=', '
        %end if
        %end for
        %echo ');'
        %slurp

	}
	else if(state->ndim == 2)
	{
		// Basic 2D loop with unrolling
		cphvb_index outer_stride0 = state->stride[0][0];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index outer_stride${op_n} = state->stride[${op_n}][0];
        %end if
        %end for

		cphvb_index inner_stride0 = state->stride[0][1];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index inner_stride${op_n} = state->stride[${op_n}][1];
        %end if
        %end for

		cphvb_index remainder;
		cphvb_index fulls;

		if (cstate->slack != 0)
		{
			remainder = cstate->slack % 4;
			fulls = cstate->slack / 4;
		
			//Macro magic time!
            %echo '            INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo 'd'+str($op_n)+', '
            %else
            %echo 'c, '
            %end if
            %end for
            %set sep=''
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo $sep+"inner_stride"+str($op_n)
            %set sep=', '
            %end if
            %end for
            %echo ');'
            %slurp
			
			d0 += outer_stride0;
            %for $op_n, $op_t in $traverse.ops[1:]
            %if $op_t == 'a'
			d${op_n} += outer_stride${op_n};
            %end if
            %end for
			
			elements -= cstate->slack;
		}

		remainder = state->shape[1] % 4;
		fulls = state->shape[1] / 4;
		cphvb_index ops_outer = elements / state->shape[1];

		for (i = 0; i < ops_outer; i++)
		{
			//Macro magic time!
            %echo '            INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo 'd'+str($op_n)+', '
            %else
            %echo 'c, '
            %end if
            %end for
            %set sep=''
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo $sep+"inner_stride"+str($op_n)
            %set sep=', '
            %end if
            %end for
            %echo ');'
            %slurp

			d0 += outer_stride0;
            %for $op_n, $op_t in $traverse.ops[1:]
            %if $op_t == 'a'
			d${op_n} += outer_stride${op_n};
            %end if
            %end for
		}

		elements -= ops_outer * state->shape[1];
		
		if (elements > 0) 
		{
			cstate->slack = state->shape[1] - elements;
			
			remainder = elements % 4;
			fulls = elements / 4;
		
			//Macro magic time!
            %echo '            INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo 'd'+str($op_n)+', '
            %else
            %echo 'c, '
            %end if
            %end for
            %set sep=''
            %for $op_n, $op_t in $traverse.ops
            %if $op_t == 'a'
            %echo $sep+"inner_stride"+str($op_n)
            %set sep=', '
            %end if
            %end for
            %echo ');'
            %slurp
            
		}
		else
		{
			cstate->slack = 0;
		}
	}
	else
	{
		//General case, optimal up to 3D, and almost optimal for 4D
		cphvb_index n = state->ndim - 3;
		cphvb_index* counters = cstate->counters;		
			
		//This chunk of variables prevents repeated calculations of offsets
		cphvb_index dim_index0 = n + 0;
		cphvb_index dim_index1 = n + 1;
		cphvb_index dim_index2 = n + 2;

		cphvb_index ops_outer = state->shape[dim_index0];
		cphvb_index ops_inner = state->shape[dim_index1];
		cphvb_index ops_inner_inner = state->shape[dim_index2];

		cphvb_index outer_stride0 = state->stride[0][dim_index0];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index outer_stride${op_n} = state->stride[${op_n}][dim_index0];
        %end if
        %end for

		cphvb_index inner_stride0 = state->stride[0][dim_index1];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index inner_stride${op_n} = state->stride[${op_n}][dim_index1];
        %end if
        %end for

		cphvb_index inner_inner_stride0 = state->stride[0][dim_index2];
        %for $op_n, $op_t in $traverse.ops[1:]
        %if $op_t == 'a'
		cphvb_index inner_inner_stride${op_n} = state->stride[${op_n}][dim_index2];
        %end if
        %end for
        
		cphvb_index remainder = ops_inner_inner % 4;
		cphvb_index fulls = ops_inner_inner / 4;

		// If we have slack elements we need to complete the
		// previous loop in 1d, 2d and 3d
		if (cstate->slack > 0)
		{
			cphvb_index slack = cstate->slack;
			
			if (elements < slack)
				slack = elements;
			
			cphvb_index full_inners = slack % ops_inner_inner;
			
			if (full_inners > 0) 
			{
				cphvb_index r = full_inners % 4;
				cphvb_index f = full_inners / 4;
			
				//Macro magic time!
				%echo '                INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, f, r, '
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo 'd'+str($op_n)+', '
				%else
				%echo 'c, '
				%end if
				%end for
				%set sep=''
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo $sep+"inner_inner_stride"+str($op_n)
				%set sep=', '
				%end if
				%end for
				%echo ');'
				%slurp

				d0 += inner_stride0;
				%for $op_n, $op_t in $traverse.ops[1:]
				%if $op_t == 'a'
				d${op_n} += inner_stride${op_n};
				%end if
				%end for
                    
				slack -= full_inners;
			}
			
			full_inners = slack % (ops_inner_inner * ops_inner);
			if (full_inners > 0)
			{
				for (j = 0; j < full_inners; j++)
				{
					//Macro magic time!
                    %echo '                    INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo 'd'+str($op_n)+', '
                    %else
                    %echo 'c, '
                    %end if
                    %end for
                    %set sep=''
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo $sep+"inner_inner_stride"+str($op_n)
                    %set sep=', '
                    %end if
                    %end for
                    %echo ');'
                    %slurp

					d0 += inner_stride0;
                    %for $op_n, $op_t in $traverse.ops[1:]
                    %if $op_t == 'a'
					d${op_n} += inner_stride${op_n};
                    %end if
                    %end for				
                }

				d0 += outer_stride0;
                %for $op_n, $op_t in $traverse.ops[1:]
                %if $op_t == 'a'
				d${op_n} += outer_stride${op_n};
                %end if
                %end for

				slack -= (full_inners * ops_inner_inner);
			}

			full_inners = slack / (ops_inner_inner * ops_inner);
			if (full_inners > 0)
			{
				for (i = 0; i < full_inners; i++)
				{
					for (j = 0; j < ops_inner; j++)
					{
						//Macro magic time!
						%echo '                        INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
						%for $op_n, $op_t in $traverse.ops
						%if $op_t == 'a'
						%echo 'd'+str($op_n)+', '
						%else
						%echo 'c, '
						%end if
						%end for
						%set sep=''
						%for $op_n, $op_t in $traverse.ops
						%if $op_t == 'a'
						%echo $sep+"inner_inner_stride"+str($op_n)
						%set sep=', '
						%end if
						%end for
						%echo ');'
						%slurp
	
						d0 += inner_stride0;
						%for $op_n, $op_t in $traverse.ops[1:]
						%if $op_t == 'a'
						d${op_n} += inner_stride${op_n};
						%end if
						%end for
					}
	
					d0 += outer_stride0;
					%for $op_n, $op_t in $traverse.ops[1:]
					%if $op_t == 'a'
					d${op_n} += outer_stride${op_n};
					%end if
					%end for
				}
	
				if (n > 0)
				{
					//Basically a ripple carry adder
					long p = n - 1;
	
					// Move one in current dimension
					d0 += state->stride[0][p];
					%for $op_n, $op_t in $traverse.ops[1:]
					%if $op_t == 'a'
					d${op_n} += state->stride[${op_n}][p];
					%end if
					%end for
	
					while (++counters[p] == state->shape[p] && p > 0)
					{
						counters[p] = 0;
						p--;
	
						//Update to move in the outer dimension, on carry
						d0 += state->stride[0][p];
						%for $op_n, $op_t in $traverse.ops[1:]
						%if $op_t == 'a'
						d${op_n} += state->stride[${op_n}][p];
						%end if
						%end for
					}
				}
			}
			
			elements -= cstate->slack;
		}

		cphvb_index inner_loop_elements = (ops_outer * ops_inner * ops_inner_inner);
		cphvb_index total_ops = elements / inner_loop_elements;

		elements -= total_ops * inner_loop_elements;

		while (total_ops-- > 0)
		{
			for (i = 0; i < ops_outer; i++)
			{
				for (j = 0; j < ops_inner; j++)
				{
					//Macro magic time!
                    %echo '                    INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo 'd'+str($op_n)+', '
                    %else
                    %echo 'c, '
                    %end if
                    %end for
                    %set sep=''
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo $sep+"inner_inner_stride"+str($op_n)
                    %set sep=', '
                    %end if
                    %end for
                    %echo ');'
                    %slurp

					d0 += inner_stride0;
                    %for $op_n, $op_t in $traverse.ops[1:]
                    %if $op_t == 'a'
					d${op_n} += inner_stride${op_n};
                    %end if
                    %end for
				}

				d0 += outer_stride0;
                %for $op_n, $op_t in $traverse.ops[1:]
                %if $op_t == 'a'
				d${op_n} += outer_stride${op_n};
                %end if
                %end for
			}

			if (n > 0)
			{
				//Basically a ripple carry adder
				long p = n - 1;

				// Move one in current dimension
				d0 += state->stride[0][p];
                %for $op_n, $op_t in $traverse.ops[1:]
                %if $op_t == 'a'
				d${op_n} += state->stride[${op_n}][p];
                %end if
                %end for

				while (++counters[p] == state->shape[p] && p > 0)
				{
					counters[p] = 0;
					p--;

					//Update to move in the outer dimension, on carry
					d0 += state->stride[0][p];
                    %for $op_n, $op_t in $traverse.ops[1:]
                    %if $op_t == 'a'
					d${op_n} += state->stride[${op_n}][p];
                    %end if
                    %end for
				}
			}
		}
		
		cstate->slack = (inner_loop_elements - elements) % inner_loop_elements;
		if (elements > 0)
		{
			//If we get here, must do the maximum number of partial
			// rounds in 3d, 2d and 1d
			
			inner_loop_elements = ops_inner * ops_inner_inner;
			ops_outer = elements / inner_loop_elements;
			elements -= (ops_outer * inner_loop_elements);

			//Partial 3d loop
			for (i = 0; i < ops_outer; i++)
			{
				for (j = 0; j < ops_inner; j++)
				{
					//Macro magic time!
                    %echo '                    INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo 'd'+str($op_n)+', '
                    %else
                    %echo 'c, '
                    %end if
                    %end for
                    %set sep=''
                    %for $op_n, $op_t in $traverse.ops
                    %if $op_t == 'a'
                    %echo $sep+"inner_inner_stride"+str($op_n)
                    %set sep=', '
                    %end if
                    %end for
                    %echo ');'
                    %slurp

					d0 += inner_stride0;
                    %for $op_n, $op_t in $traverse.ops[1:]
                    %if $op_t == 'a'
					d${op_n} += inner_stride${op_n};
                    %end if
                    %end for
				}

				d0 += outer_stride0;
                %for $op_n, $op_t in $traverse.ops[1:]
                %if $op_t == 'a'
				d${op_n} += outer_stride${op_n};
                %end if
                %end for
			}
						
			ops_inner = elements / ops_inner_inner;
			elements -= (ops_inner * ops_inner_inner);
			
			//Partial 2d loop
			for (j = 0; j < ops_inner; j++)
			{
				//Macro magic time!
				%echo '                INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo 'd'+str($op_n)+', '
				%else
				%echo 'c, '
				%end if
				%end for
				%set sep=''
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo $sep+"inner_inner_stride"+str($op_n)
				%set sep=', '
				%end if
				%end for
				%echo ');'
				%slurp

				d0 += inner_stride0;
				%for $op_n, $op_t in $traverse.ops[1:]
				%if $op_t == 'a'
				d${op_n} += inner_stride${op_n};
				%end if
				%end for
			}
			
			//Partial 1d loop
			if (elements > 0)
			{
				fulls = elements / 4;
				remainder = elements % 4;
				
				//Macro magic time!
				%echo '                INNER_LOOP_'+$traverse.sig.upper()+'(opcode_func, fulls, remainder, '
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo 'd'+str($op_n)+', '
				%else
				%echo 'c, '
				%end if
				%end for
				%set sep=''
				%for $op_n, $op_t in $traverse.ops
				%if $op_t == 'a'
				%echo $sep+"inner_inner_stride"+str($op_n)
				%set sep=', '
				%end if
				%end for
				%echo ');'
				%slurp
				
			}
		}
	}	

	cstate->start[0] = d0;
    %for $op_n, $op_t in $traverse.ops[1:]
    %if $op_t == 'a'
    cstate->start[${op_n}] = d${op_n};
    %end if
    %end for
	
    return CPHVB_SUCCESS;
}

%end for


