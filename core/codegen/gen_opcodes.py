#!/usr/bin/env python
import json 
import sys
import os
import re
import time
import stat
import collections

"""
    Generates the include/cphvb_opcode.h and core/cphvb_opcode 
    based on the definitnion in /core/codegen/opcodes.json.
"""

def gen_headerfile( opcodes ):

    enums = ("        %s,\t\t// %s" % (opcode['opcode'], opcode['doc']) for opcode in opcodes)
    stamp   = time.strftime("%d/%m/%Y")

    return """
/*
 * Do not edit this file. It has been auto generate by 
 * ../core/codegen/gen_opcodes.py at __TIMESTAMP__.
 */

#ifndef __CPHVB_OPCODE_H
#define __CPHVB_OPCODE_H

#include "cphvb_type.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Codes for known oparations */
enum /* cphvb_opcode */
{
__OPCODES__

    CPHVB_NO_OPCODES    // The amount of opcodes
};

#ifdef __cplusplus
}
#endif

#endif
""".replace('__TIMESTAMP__', stamp).replace('__OPCODES__', '\n'.join(enums))

def gen_cfile(opcodes):

    text    = ['        case %s: return "%s";' % (opcode['opcode'], opcode['opcode']) for opcode in opcodes]
    nops    = ['        case %s: return %s;' % (opcode['opcode'], opcode['nop']) for opcode in opcodes]
    stamp   = time.strftime("%d/%m/%Y")

    return """
/*
 * Do not edit this file. It has been auto generate by 
 * ../core/codegen/gen_opcodes.py at __TIMESTAMP__.
 */

#include <stdlib.h>
#include <stdio.h>
#include <cphvb_opcode.h>
#include <cphvb.h>
#include <stdbool.h>


/* Number of operands for operation
 *
 * @opcode Opcode for operation
 * @return Number of operands
 */
int cphvb_operands(cphvb_opcode opcode)
{
    switch(opcode) 
    {
__NOPS__

    default:
        return -1;
    }
}

/* Number of operands in instruction
 * NB: this function handles user-defined function correctly
 * @inst Instruction
 * @return Number of operands
 */
int cphvb_operands_in_instruction(cphvb_instruction *inst)
{
    if (inst->opcode == CPHVB_USERFUNC)
        return inst->userfunc->nin + inst->userfunc->nout;
    else
        return cphvb_operands(inst->opcode);
}

/* Text descriptions for a given operation */
const char* _opcode_text[CPHVB_NONE+1];
bool _opcode_text_initialized = false;

/* Text string for operation
 *
 * @opcode Opcode for operation
 * @return Text string.
 */
const char* cphvb_opcode_text(cphvb_opcode opcode)
{
    switch(opcode)
    {
__TEXT__

        default: return "Unknown opcode";
    }
}
    """.replace('__TIMESTAMP__', stamp).replace('__NOPS__', '\n'.join(nops)).replace('__TEXT__', '\n'.join(text))

def get_timestamp(f):
    st = os.stat(f)
    atime = st[stat.ST_ATIME] #access time
    mtime = st[stat.ST_MTIME] #modification time
    return (atime,mtime)

def set_timestamp(f,timestamp):
    os.utime(f,timestamp)

def main(script_dir):

    # Save the newest timestamp of this file and the definition file.
    # We will set this timest   
    timestamp = get_timestamp(os.path.join(script_dir,'gen_opcodes.py'))
    t = get_timestamp(os.path.join(script_dir,'opcodes.json'))
    timestamp = t if t[1] > timestamp[1] else timestamp

    # Read the opcode definitions from opcodes.json. 
    opcodes = json.loads(open(os.path.join(script_dir,'opcodes.json')).read())
    
    # Write the header file
    headerfile  = gen_headerfile(opcodes)
    cfile       = gen_cfile(opcodes)    

    name = os.path.join(script_dir,'..','..','include','cphvb_opcode.h')
    h = open(name,"w")
    h.write(headerfile)
    h.close()
    set_timestamp(name, timestamp)

    # Write the c file
    name = os.path.join(script_dir,'..','cphvb_opcode.c')
    h = open(name,"w")
    h.write(cfile)    
    h.close()
    set_timestamp(name, timestamp)

if __name__ == "__main__":
    try:
        script_dir = os.path.abspath(os.path.dirname(__file__))
    except NameError:
        print "The build script cannot run interactively."
        sys.exit(-1)
    main(script_dir)
