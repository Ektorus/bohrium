import util
if util.Benchmark().bohrium:
    import bohrium as np
else:
    import numpy as np
from bohrium.stdviews import D2P8, no_border

def wireworld_init(size):
    """TODO: Describe the data generated by this function."""

    data = np.zeros(
        (size*10+2, size*10+2),
        dtype   = np.uint8
    )
    data[1:-1,1:-1] = np.tile(np.array([
        [4,2,8,8,8,8,8,8,8,8],
        [8,0,0,0,8,0,0,0,0,0],
        [0,0,0,8,8,8,0,0,0,0],
        [8,0,0,0,8,0,0,0,0,0],
        [2,4,8,8,0,8,8,8,8,8],
        [4,2,8,8,8,8,8,8,8,8],
        [8,0,0,0,8,0,0,0,0,0],
        [0,0,0,8,8,8,0,0,0,0],
        [8,0,0,0,8,0,0,0,0,0],
        [2,4,8,8,0,8,8,8,8,8],
        ]),(size,size))

    return data

def wireworld(world, iterations):
    """TODO: Describe the benchmark."""

    sim     = no_border(world, 1)   # Active Machine
    stencil = D2P8(world)           # Stencil for counting heads
    for _ in xrange(iterations):
        NC = sum([v==2 for v in stencil]) # Count number of head neighbors
        # Mask conductor->head
        MASK = ((NC==1) & (sim==8)) | ((NC==2) & (sim==8))
        sim *= ~MASK    # New head pos->0
        sim += MASK * 1 # New head pos->1
        MASK = (sim==8) # Mask non conductors
        sim *= ~MASK    # conductors->0
        sim += MASK * 4 # conductors->4   
        sim *= 2        # Upgrade all to new state

    return sim

if __name__ == "__main__":
    """
    Example parameter: --size=1000*10.
    This will execute on a 1000x1000 dataset for 10 iterations.
    """
    B = util.Benchmark()
    (N, I) = B.size
    world = wireworld_init(N)
    world + 1   # Ensure that data is in the correct space.
    B.start()
    result = wireworld(world, I)
    B.stop()
    B.pprint()
