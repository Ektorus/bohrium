#include "block.hpp"
//
//  NOTE: This file is autogenerated based on the tac-definition.
//        You should therefore not edit it manually.
//
using namespace std;
namespace bohrium{
namespace engine{
namespace cpu{

/**
 *  Compose a block based on the instruction-nodes within a dag.
 */
bool Block::compose()
{
    if (this->dag.nnode<1) {
        fprintf(stderr, "Got an empty dag. This cannot be right...\n");
        return false;
    }
    bool compose_res = compose(0, this->dag.nnode-1);

    return compose_res;
}

/**
 *  Compose a block based on the instruction-nodes within a dag.
 *  Starting from and including node_start to and including node_end.
 */
bool Block::compose(bh_intp node_start, bh_intp node_end)
{
    DEBUG(TAG, "compose("<< node_start <<", "<< node_end << ") : node_span(" << ((node_end-node_start)+1) << ")");
    if (this->dag.nnode<1) {
        fprintf(stderr, "Got an empty dag. This cannot be right...\n");
        return false;
    }
    
    // Reset metadata
    ntacs_      = 0;        // The number of tacs in block
    noperands_  = 0;        // The number of operands
    omask_      = 0;        // And the operation mask
    symbol_         = "";
    symbol_text_    = "";       // Symbol of the block
    operand_map.clear();    // tac-operand to block scope mapping
    
    size_t pc = 0;
    for (int node_idx=node_start; node_idx<=node_end; ++node_idx, ++pc, ++ntacs_) {
        
        if (dag.node_map[node_idx] <0) {
            fprintf(stderr, "Code-generation for subgraphs is not supported yet.\n");
            return false;
        }

        this->instr_[pc] = &this->ir.instr_list[dag.node_map[node_idx]];
        bh_instruction& instr = *this->instr_[pc];

        uint32_t out=0, in1=0, in2=0;

        //
        // Program packing: output argument
        // NOTE: All but BH_NONE has an output which is an array
        if (instr.opcode != BH_NONE) {
            out = this->add_operand(instr, 0);
        }

        //
        // Program packing; operator, operand and input argument(s).
        switch (instr.opcode) {    // [OPCODE_SWITCH]

            case BH_ABSOLUTE:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ABSOLUTE;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCCOS:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCCOS;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCCOSH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCCOSH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCSIN:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCSIN;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCSINH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCSINH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCTAN:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCTAN;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ARCTANH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ARCTANH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_CEIL:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = CEIL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_COS:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = COS;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_COSH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = COSH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_EXP:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = EXP;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_EXP2:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = EXP2;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_EXPM1:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = EXPM1;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_FLOOR:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = FLOOR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_IDENTITY:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = IDENTITY;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_IMAG:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = IMAG;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_INVERT:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = INVERT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ISINF:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ISINF;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ISNAN:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = ISNAN;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_LOG:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = LOG;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_LOG10:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = LOG10;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_LOG1P:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = LOG1P;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_LOG2:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = LOG2;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_LOGICAL_NOT:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = LOGICAL_NOT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_REAL:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = REAL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_RINT:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = RINT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_SIN:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = SIN;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_SINH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = SINH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_SQRT:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = SQRT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_TAN:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = TAN;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_TANH:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = TANH;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_TRUNC:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = MAP;  // TAC
                this->tacs[pc].oper  = TRUNC;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= MAP;    // Operationmask
                break;
            case BH_ADD:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = ADD;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_ARCTAN2:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = ARCTAN2;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_BITWISE_AND:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = BITWISE_AND;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_BITWISE_OR:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = BITWISE_OR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_BITWISE_XOR:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = BITWISE_XOR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_DIVIDE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = DIVIDE;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_EQUAL:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = EQUAL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_GREATER:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = GREATER;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_GREATER_EQUAL:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = GREATER_EQUAL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LEFT_SHIFT:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LEFT_SHIFT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LESS:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LESS;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LESS_EQUAL:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LESS_EQUAL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LOGICAL_AND:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LOGICAL_AND;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LOGICAL_OR:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LOGICAL_OR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_LOGICAL_XOR:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = LOGICAL_XOR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_MAXIMUM:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = MAXIMUM;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_MINIMUM:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = MINIMUM;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_MOD:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = MOD;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_MULTIPLY:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = MULTIPLY;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_NOT_EQUAL:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = NOT_EQUAL;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_POWER:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = POWER;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_RIGHT_SHIFT:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = RIGHT_SHIFT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_SUBTRACT:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = ZIP;  // TAC
                this->tacs[pc].oper  = SUBTRACT;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= ZIP;    // Operationmask
                break;
            case BH_ADD_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = ADD;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_BITWISE_AND_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = BITWISE_AND;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_BITWISE_OR_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = BITWISE_OR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_BITWISE_XOR_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = BITWISE_XOR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_LOGICAL_AND_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = LOGICAL_AND;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_LOGICAL_OR_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = LOGICAL_OR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_LOGICAL_XOR_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = LOGICAL_XOR;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_MAXIMUM_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = MAXIMUM;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_MINIMUM_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = MINIMUM;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_MULTIPLY_REDUCE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = REDUCE;  // TAC
                this->tacs[pc].oper  = MULTIPLY;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= REDUCE;    // Operationmask
                break;
            case BH_ADD_ACCUMULATE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = SCAN;  // TAC
                this->tacs[pc].oper  = ADD;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SCAN;    // Operationmask
                break;
            case BH_MULTIPLY_ACCUMULATE:
                in1 = this->add_operand(instr, 1);
                in2 = this->add_operand(instr, 2);

                this->tacs[pc].op    = SCAN;  // TAC
                this->tacs[pc].oper  = MULTIPLY;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SCAN;    // Operationmask
                break;
            case BH_RANDOM:
                in1 = this->add_operand(instr, 1);

                this->tacs[pc].op    = GENERATE;  // TAC
                this->tacs[pc].oper  = RANDOM;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= GENERATE;    // Operationmask
                break;
            case BH_RANGE:

                this->tacs[pc].op    = GENERATE;  // TAC
                this->tacs[pc].oper  = RANGE;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= GENERATE;    // Operationmask
                break;
            case BH_DISCARD:

                this->tacs[pc].op    = SYSTEM;  // TAC
                this->tacs[pc].oper  = DISCARD;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SYSTEM;    // Operationmask
                break;
            case BH_FREE:

                this->tacs[pc].op    = SYSTEM;  // TAC
                this->tacs[pc].oper  = FREE;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SYSTEM;    // Operationmask
                break;
            case BH_NONE:

                this->tacs[pc].op    = SYSTEM;  // TAC
                this->tacs[pc].oper  = NONE;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SYSTEM;    // Operationmask
                break;
            case BH_SYNC:

                this->tacs[pc].op    = SYSTEM;  // TAC
                this->tacs[pc].oper  = SYNC;
                this->tacs[pc].out   = out;
                this->tacs[pc].in1   = in1;
                this->tacs[pc].in2   = in2;
            
                this->omask_ |= SYSTEM;    // Operationmask
                break;

            default:
                if (instr.opcode>=BH_MAX_OPCODE_ID) {   // Handle extensions here

                    in1 = this->add_operand(instr, 1);
                    in2 = this->add_operand(instr, 2);

                    this->tacs[pc].op   = EXTENSION;
                    this->tacs[pc].oper = EXTENSION_OPERATOR;
                    this->tacs[pc].out  = out;
                    this->tacs[pc].in1  = in1;
                    this->tacs[pc].in2  = in2;

                    this->omask_ |= EXTENSION;
                    break;

                } else {
                    fprintf(stderr, "Block::compose: Err=[Unsupported instruction] {\n");
                    bh_pprint_instr(&instr);
                    fprintf(stderr, "}\n");
                    return false;
                }
        }

        //
        // Update the ref count
        symbol_table.ref_count(this->tacs[pc]);
    }
    DEBUG(TAG, "compose(SUCCESS)");
    return true;
}

}}}
