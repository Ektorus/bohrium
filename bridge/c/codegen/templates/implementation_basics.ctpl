#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
%set $ops = $data[0]
%set $reduce_ops = $data[1]


#include <bh.hpp>
#include <bh_c_data_types.h>
#include <bh_c_interface.h>
#include "bh_c_type_definitions.hpp"
#include <bh.h>

using namespace bh;

// Common runtime methods
void bh_runtime_flush() {
    Runtime::instance().flush();
}

%for $ctype, $bh_atype, $bh_ctype, $bh_enum in $ops

// $bh_enum

// Create a base pointer from existing data
bh_base_p bh_multi_array_${bh_ctype}_create_base(${bh_atype}* data, int64_t nelem)
{
    bh_base_p base = new bh_base;
    assign_array_type<${bh_atype}>(base);
    base->nelem = nelem;
    base->data  = data;

    return base;
}

// Destroy a base pointer
void bh_multi_array_${bh_ctype}_destroy_base(bh_base_p base)
{
    delete base;
}

// Gets the data pointer from a base
${bh_atype}* bh_multi_array_${bh_ctype}_get_base_data(bh_base_p base)
{
    return (${bh_atype}*)base->data;
}

// Gets the data pointer from a base and force memory allocation
// Return NULL when out of memory
${bh_atype}* bh_multi_array_${bh_ctype}_get_base_data_and_force_alloc(bh_base_p base)
{
    if(bh_data_malloc(base) != 0)
        return NULL;

    return (${bh_atype}*)base->data;
}

// Gets the number of elements in a base
int64_t bh_multi_array_${bh_ctype}_get_base_nelem(bh_base_p base)
{
    return base->nelem;
}

// Sets the data pointer for a base
void bh_multi_array_${bh_ctype}_set_base_data(bh_base_p base, ${bh_atype}* data)
{
    base->data = data;
}

// Nullify the data pointer for a base
void bh_multi_array_${bh_ctype}_nullify_base_data(bh_base_p base)
{
    base->data = NULL;
}

// Get the base from an existing array
bh_base_p bh_multi_array_${bh_ctype}_get_base(const bh_multi_array_${bh_ctype}_p self)
{
    return ((multi_array<${ctype}>*)self)->getBase();
}

// Sync the current base
void bh_multi_array_${bh_ctype}_sync(const bh_multi_array_${bh_ctype}_p self)
{
    ((multi_array<${ctype}>*)self)->sync();
}

// Sets the temp status of an array
void bh_multi_array_${bh_ctype}_set_temp(const bh_multi_array_${bh_ctype}_p self, bh_bool temp)
{
    ((multi_array<${ctype}>*)self)->setTemp(temp);
}

// Gets the temp status of an array
bh_bool bh_multi_array_${bh_ctype}_get_temp(const bh_multi_array_${bh_ctype}_p self)
{
    return ((multi_array<${ctype}>*)self)->getTemp();
}

// Construct a new array from bh_base_p and view setup
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_from_base(const bh_base_p base)
{
    const int64_t stride = 1;
    const int64_t shape = base->nelem;
    bh_multi_array_${bh_ctype}_p self = bh_multi_array_${bh_ctype}_new_from_view(base, 1, 0, &shape, &stride);
    ((multi_array<${ctype}>*)self)->link(base);

    return self;
}


// Construct a new array from bh_base_p and bh_view_p
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_from_view(const bh_base_p base, uint64_t rank, const int64_t start, const int64_t* shape, const int64_t* stride)
{
    bh_multi_array_${bh_ctype}_p tmp = (bh_multi_array_${bh_ctype}_p)new multi_array<${ctype}>(base, rank, start, shape, stride);
    return tmp;
}


// Construct a new sized array
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_empty(uint64_t rank, const int64_t* shape) {
    multi_array<${ctype}>* result = new multi_array<${ctype}>(rank, shape);
    result->setTemp(false);
    result->link();
    return (bh_multi_array_${bh_ctype}_p)result;
}

%if $bh_ctype != "bool8"
// Construct a new zero-filled array
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_zeroes(uint64_t rank, const int64_t* shape) {
    multi_array<${ctype}>* result = new multi_array<${ctype}>(rank, shape);
    result->setTemp(true);
    result->link();
    *result = (${ctype})0;

    return (bh_multi_array_${bh_ctype}_p)result;
}

// Construct a new one-filled array
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_ones(uint64_t rank, const int64_t* shape) {
    multi_array<${ctype}>* result = new multi_array<${ctype}>(rank, shape);
    result->setTemp(true);
    result->link();
    *result = (${ctype})1;

    return (bh_multi_array_${bh_ctype}_p)result;
}

// Construct a new array with sequential numbers
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_range(const int64_t start, const int64_t end, const int64_t skip) {
    bh_multi_array_uint64_p tmp;
    tmp = (bh_multi_array_uint64_p)&(range<uint64_t>(start, end, skip));

%if $bh_ctype != "uint64"
    bh_multi_array_${bh_ctype}_p result;
    result = bh_multi_array_${bh_ctype}_convert_uint64(tmp);
    return result;
%else
    return tmp;
%end if
}
%end if

// Construct a new random-filled array
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_random(const int64_t length) {
    return (bh_multi_array_${bh_ctype}_p)&(random<${ctype}>(length));
}

// Construct a new array, filled with the specified value
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_value(const ${bh_atype} value, uint64_t rank, const int64_t* shape) {
    multi_array<${ctype}>* result = new multi_array<${ctype}>(rank, shape);
    result->setTemp(true);
    result->link();
%if $bh_ctype == "complex64" or $bh_ctype == "complex128"
    ${ctype} t;
    t.real(value.real);
    t.imag(value.imag);

    *result = t;
%else
    *result = value;
%end if

    return (bh_multi_array_${bh_ctype}_p)result;
}

// Construct a copy of the array
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_copy(bh_multi_array_${bh_ctype}_p other) {
    return (bh_multi_array_${bh_ctype}_p)new multi_array<${ctype}>(*((multi_array<${ctype}>*)other));
}

// Destroy the pointer and release resources
void bh_multi_array_${bh_ctype}_destroy(bh_multi_array_${bh_ctype}_p self) {
    delete ((multi_array<${ctype}>*)self);
}

// Gets the number of elements in the array
uint64_t bh_multi_array_${bh_ctype}_get_length(bh_multi_array_${bh_ctype}_p self) {
    return ((multi_array<${ctype}>*)self)->len();
}

// Gets the number of dimensions in the array
uint64_t bh_multi_array_${bh_ctype}_get_rank(bh_multi_array_${bh_ctype}_p self) {
    return ((multi_array<${ctype}>*)self)->getRank();
}

// Gets the number of elements in the dimension
uint64_t bh_multi_array_${bh_ctype}_get_dimension_size(bh_multi_array_${bh_ctype}_p self, const int64_t size) {
    return ((multi_array<${ctype}>*)self)->shape(size);
}

// Update with a scalar
void bh_multi_array_${bh_ctype}_assign_scalar(bh_multi_array_${bh_ctype}_p self, const ${bh_atype} value) {
%if $bh_ctype == "complex64" or $bh_ctype == "complex128"
    ${ctype} t;
    t.real(value.real);
    t.imag(value.imag);

    (*((multi_array<${ctype}>*)self))(t);
%else
    (*((multi_array<${ctype}>*)self))(value);
%end if

}

// Update with an array
void bh_multi_array_${bh_ctype}_assign_array(bh_multi_array_${bh_ctype}_p self, bh_multi_array_${bh_ctype}_p other) {
    (*((multi_array<${ctype}>*)self))(*((multi_array<${ctype}>*)other));
}

// Update with an data
void bh_multi_array_${bh_ctype}_assign_data(bh_multi_array_${bh_ctype}_p self, const void* data) {
    (*((multi_array<${ctype}>*)self))((${ctype}*)data);
}

// Flatten view
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_flatten(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_${bh_ctype}_p)&flatten((*((multi_array<${ctype}>*)self)));
}

// Transpose view
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_transpose(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_${bh_ctype}_p)&transpose((*((multi_array<${ctype}>*)self)));
}

%for $opname, $enum in $reduce_ops
// Partial ${opname} reduction
bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_partial_reduce_${opname}(bh_multi_array_${bh_ctype}_p self, const int64_t axis) {
    return (bh_multi_array_${bh_ctype}_p)&reduce(*((multi_array<${ctype}>*)self), ${enum}, axis);
}

%end for

%if $bh_atype == "bh_complex64" or $bh_atype == "bh_complex128"
// Sum
${bh_atype} bh_multi_array_${bh_ctype}_sum(bh_multi_array_${bh_ctype}_p self) {
    ${bh_atype} t1;
    ${ctype} t0 = scalar(sum(*((multi_array<${ctype}>*)self)));
    t1.real = t0.real();
    t1.imag = t0.imag();
    return t1;
}
// Product
${bh_atype} bh_multi_array_${bh_ctype}_product(bh_multi_array_${bh_ctype}_p self) {
    ${bh_atype} t1;
    ${ctype} t0 = scalar(product(*((multi_array<${ctype}>*)self)));
    t1.real = t0.real();
    t1.imag = t0.imag();
    return t1;
}
%else if $bh_atype == "bh_bool"

// All
${bh_atype} bh_multi_array_${bh_ctype}_all(bh_multi_array_${bh_ctype}_p self) {
    return scalar(all(*((multi_array<${ctype}>*)self)));
}

// Any
${bh_atype} bh_multi_array_${bh_ctype}_any(bh_multi_array_${bh_ctype}_p self) {
    return scalar(any(*((multi_array<${ctype}>*)self)));
}

%else
// Sum
${bh_atype} bh_multi_array_${bh_ctype}_sum(bh_multi_array_${bh_ctype}_p self) {
    return scalar(sum(*((multi_array<${ctype}>*)self)));
}
// Product
${bh_atype} bh_multi_array_${bh_ctype}_product(bh_multi_array_${bh_ctype}_p self) {
    return scalar(product(*((multi_array<${ctype}>*)self)));
}
%end if

%if $bh_atype != "bh_complex64" and $bh_atype != "bh_complex128"

// Max
${bh_atype} bh_multi_array_${bh_ctype}_max(bh_multi_array_${bh_ctype}_p self) {
    return scalar(max(*((multi_array<${ctype}>*)self)));
}

// Min
${bh_atype} bh_multi_array_${bh_ctype}_min(bh_multi_array_${bh_ctype}_p self) {
    return scalar(min(*((multi_array<${ctype}>*)self)));
}

%end if
%if $bh_atype == "bh_complex64"

bh_multi_array_float32_p bh_multi_array_${bh_ctype}_real(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_float32_p)&(real<${ctype}, float>(*((multi_array<${ctype}>*)self)));
}

bh_multi_array_float32_p bh_multi_array_${bh_ctype}_imag(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_float32_p)&(imag<${ctype}, float>(*((multi_array<${ctype}>*)self)));
}

%end if

%if $bh_atype == "bh_complex128"

bh_multi_array_float64_p bh_multi_array_${bh_ctype}_real(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_float64_p)&(real<${ctype}, double>(*((multi_array<${ctype}>*)self)));
}

bh_multi_array_float64_p bh_multi_array_${bh_ctype}_imag(bh_multi_array_${bh_ctype}_p self) {
    return (bh_multi_array_float64_p)&(imag<${ctype}, double>(*((multi_array<${ctype}>*)self)));
}

%end if

    %for $ctype2, $bh_atype2, $bh_ctype2, $bh_enum2 in $ops
        %for $ctype3, $bh_atype3, $bh_ctype3, $bh_enum3 in $ops
            %if $bh_ctype2 == $bh_ctype3

void bh_multi_array_extmethod_${bh_ctype}_${bh_ctype2}_${bh_ctype3}(const char *name, bh_multi_array_${bh_ctype}_p out, bh_multi_array_${bh_ctype2}_p in1, bh_multi_array_${bh_ctype3}_p in2) {
    Runtime::instance().enqueue_extension(name, *((multi_array<${ctype}>*) out), *((multi_array<${ctype2}>*) in1), *((multi_array<${ctype3}>*) in2));
}
            %end if
        %end for
    %end for

%end for
