#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
/*
 * Copyright 2011 Simon A. F. Lund <safl@safl.dk>
 *
 * This file is part of cphVB.
 *
 * cphVB is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * cphVB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with cphVB. If not, see <http://www.gnu.org/licenses/>.
 */
#include <cphvb.h>
#include <cphvb_compute.h>
#include "functors.hpp"
#include "traverser.hpp"

cphvb_error cphvb_compute_apply( cphvb_instruction *instr ) {

    computeloop comp = cphvb_compute_get( instr );
    if (comp == NULL)
    {
        return CPHVB_TYPE_NOT_SUPPORTED;
    } else {
        return comp( instr, (cphvb_index)0, (cphvb_index)0 );
    }

}

cphvb_error cphvb_compute_apply_unsafe( cphvb_instruction *instr ) {

    computeloop comp = cphvb_compute_get( instr );
    return comp( instr, (cphvb_index)0, (cphvb_index)0 );

}

computeloop cphvb_compute_get( cphvb_instruction *instr ) {

    // Poly contains a unique value, pairing an opcode with its function signature.
    // All in one nicely switchable value.
    long int poly;
 
    if (cphvb_operands(instr->opcode) == 3) {   // Three operands

        if (cphvb_is_constant(instr->operand[1])) {             // First operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(instr->operand[2]->type << 16) \
                +(1 << 17);

        } else if (cphvb_is_constant(instr->operand[2])) {      // Second operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->constant.type << 16) \
                +(1 << 18);

        } else {                                                // No constant operand
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->operand[2]->type << 16);
        }

    } else {                                    // Two operands

        if (cphvb_is_constant(instr->operand[1])) {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(1 << 17);
        } else {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12);
        }
    }

    switch(poly) {

        %for $case in $cases
        %if $case.opcount == 2
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12):
            return &traverse_aa<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (1 << 17):
            return &traverse_ac<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        %else
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16):
            return &traverse_aaa<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 18):
            return &traverse_aac<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 17):
            return &traverse_aca<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        %end if
        %end for

        default:
            return NULL;

    }

}

