#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
/*
This file is part of cphVB and copyright (c) 2012 the cphVB team:
http://cphvb.bitbucket.org

cphVB is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

cphVB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with cphVB. 

If not, see <http://www.gnu.org/licenses/>.
*/
#include <cphvb.h>
#include <cphvb_compute.h>
#include "functors.hpp"
#include "traverser.hpp"
#include <complex>

void cphvb_tstate_reset( cphvb_tstate *state ) {
    memset(state->coord, 0, CPHVB_MAXDIM * sizeof(cphvb_index));
    state->cur_e = 0;   
}

cphvb_error cphvb_compute_apply( cphvb_instruction *instr ) {

    computeloop comp = cphvb_compute_get( instr );
    cphvb_tstate state;
    cphvb_tstate_reset( &state );
    
    if (comp == NULL) {
        return CPHVB_TYPE_NOT_SUPPORTED;
    } else {
        return comp( instr, &state, 0 );
    }

}

cphvb_error cphvb_compute_apply_unsafe( cphvb_instruction *instr ) {

    computeloop comp = cphvb_compute_get( instr );
    cphvb_tstate state;
    cphvb_tstate_reset( &state );

    return comp( instr, &state, 0 );

}

computeloop cphvb_compute_get( cphvb_instruction *instr ) {

    // Poly contains a unique value, pairing an opcode with its function signature.
    // All in one nicely switchable value.
    long int poly;
 
    if (cphvb_operands(instr->opcode) == 3) {   // Three operands

        if (cphvb_is_constant(instr->operand[1])) {             // First operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(instr->operand[2]->type << 16) \
                +(1 << 17);

        } else if (cphvb_is_constant(instr->operand[2])) {      // Second operand is constant
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->constant.type << 16) \
                +(1 << 18);

        } else {                                                // No constant operand
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12) \
                +(instr->operand[2]->type << 16);
        }

    } else {                                    // Two operands

        if (cphvb_is_constant(instr->operand[1])) {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->constant.type << 12) \
                +(1 << 17);
        } else {
            poly = instr->opcode \
                +(instr->operand[0]->type << 8) \
                +(instr->operand[1]->type << 12);
        }
    }

    switch(poly) {

        %for $case in $data
        %if $case.nop == 2
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12):
            return &traverse_aa<${case.ftypes}, ${case.fname}_functor<${case.ftypes} > >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (1 << 17):
            return &traverse_ac<${case.ftypes}, ${case.fname}_functor<${case.ftypes} > >;
            break;
        %else
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16):
            return &traverse_aaa<${case.ftypes}, ${case.fname}_functor<${case.ftypes} > >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 18):
            return &traverse_aac<${case.ftypes}, ${case.fname}_functor<${case.ftypes} > >;
            break;
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16) + (1 << 17):
            return &traverse_aca<${case.ftypes}, ${case.fname}_functor<${case.ftypes} > >;
            break;
        %end if
        %end for

        default:
            return NULL;

    }

}

