#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the
GNU Lesser General Public License along with Bohrium.

If not, see <http://www.gnu.org/licenses/>.
*/
#include <bh.h>
#include <bh_compute.h>
#include <bh_vcache.h>
#include "functors.hpp"
#include <complex>
#include <assert.h>
#include "functors.hpp"
#include "traverser.hpp"

typedef char BYTE;

// These are legacy

template <typename T, typename Instr>
bh_error bh_compute_reduce_any_naive( bh_view* op_out, bh_view* op_in, bh_index axis, bh_opcode opcode )
{
    Instr opcode_func;                          // Functor-pointer
                                                // Data pointers
    T* data_out = (T*) bh_base_array(op_out)->data;
    T* data_in  = (T*) bh_base_array(op_in)->data;

    bh_index stride      = op_in->stride[axis];
    bh_index nelements   = op_in->shape[axis];
    bh_index i, j, off0;

    if (op_in->ndim == 1) {                     // 1D special case

        data_out += op_out->start;
        *data_out = *(data_in+op_in->start);    // Initialize pseudo-scalar output
                                                // the value of the first element
                                                // in input.
        for(off0 = op_in->start+stride, j=1; j < nelements; j++, off0 += stride ) {
            opcode_func( data_out, data_out, (data_in+off0) );
        }

        return BH_SUCCESS;

    } else {                                    // ND general case

        bh_instruction instr;
        bh_error err;

        bh_view *tmp = &instr.operand[1];  // Copy the input-array meta-data
        tmp->base    = bh_base_array(op_in);
        tmp->ndim    = op_in->ndim-1;
        tmp->start   = op_in->start;

        for(j=0, i=0; i < op_in->ndim; ++i) {        // Copy every dimension except for the 'axis' dimension.
            if(i != axis) {
                tmp->shape[j]    = op_in->shape[i];
                tmp->stride[j]   = op_in->stride[i];
                ++j;
            }
        }

        instr.opcode = BH_IDENTITY;       // Copy the first element to the output.
        instr.operand[0] = *op_out;

        err = bh_compute_apply_naive( &instr );
        if (err != BH_SUCCESS) {
            return err;
        }
        tmp->start += stride;

        instr.opcode = opcode;                   // Reduce over the 'axis' dimension.
        instr.operand[0] = *op_out;              // NB: the first element is already handled.
        instr.operand[2] = *op_out;              // Note that operand[1] is still the tmp view

        for(i=1; i<nelements; ++i) {
            err = bh_compute_apply_naive( &instr );
            if (err != BH_SUCCESS) {
                return err;
            }
            tmp->start += stride;
        }
        return BH_SUCCESS;
    }
}

bh_error bh_compute_reduce_naive(bh_instruction *inst)
{
    if (inst->constant.type != BH_INT64)
        return BH_TYPE_NOT_SUPPORTED;

    bh_index axis = inst->constant.value.int64;
    bh_opcode opcode;
    bh_view *op_out = &inst->operand[0];
    bh_view *op_in  = &inst->operand[1];

    assert(op_out != NULL);

    switch (inst->opcode)
    {
        %set $lastopcode = ''
        %for $case in $data
        %if $case.opcode != $lastopcode
        case ${case.opcode}_REDUCE:
            opcode = ${case.opcode};
            break;
        %end if
        %set $lastopcode = $case.opcode
        %end for
        default:
            return BH_TYPE_NOT_SUPPORTED;
    }

                                                        //  Sanity checks.
    if (bh_operands(opcode) != 3) {
        fprintf(stderr, "ERR: opcode: %lld is not a binary ufunc, hence it is not suitable for reduction.\n", (long long int)opcode);
        return BH_ERROR;
    }

    if (bh_base_array(op_in)->data == NULL) {
        fprintf(stderr, "ERR: bh_compute_reduce; input-operand ( op_in ) is null.\n");
        return BH_ERROR;
    }

    if (op_in->base->type != op_out->base->type) {
        fprintf(stderr, "ERR: bh_compute_reduce; input and output types are mixed."
                        "Probable causes include reducing over 'LESS', just dont...\n");
        return BH_ERROR;
    }

    long int poly = opcode + (op_in->base->type << 8);

    switch(poly) {

        %for $case in $data
        case ${case.opcode} + (${case.op1} << 8):
            return bh_compute_reduce_any_naive<${case.ftype}, ${case.fname}_functor<${case.ftype}, ${case.ftype}, ${case.ftype} > >( op_out, op_in, axis, opcode );
        %end for

        default:

            return BH_ERROR;

    }

}

// These are the future

template <typename T, typename Instr>
bh_error bh_compute_reduce_any( bh_view* op_out, bh_view* op_in, bh_index axis, bh_opcode opcode )
{
    Instr opcode_func;                          // Functor-pointer
                                                // Data pointers
    T* data_out = (T*) bh_base_array(op_out)->data;
    T* data_in  = (T*) bh_base_array(op_in)->data;

    bh_index nelements   = op_in->shape[axis];
    bh_index i, j;

    bh_index el_size = sizeof(T);

    if (op_in->ndim == 1) {                     // 1D special case

        data_out += op_out->start;
        *data_out = *(data_in+op_in->start);    // Initialize pseudo-scalar output
                                                // the value of the first element
                                                // in input.
        bh_index stride = op_in->stride[axis] * el_size;
        BYTE* src = ((BYTE*)(data_in + op_in->start)) + stride;

        // 4x Loop unrolling
        bh_index fulls = (nelements - 1) / 4;
        bh_index remainder = (nelements - 1) % 4;

        for (i = 0; i < fulls; i++) {
            opcode_func( data_out, data_out, ((T*)src) );
            src += stride;
            opcode_func( data_out, data_out, ((T*)src) );
            src += stride;
            opcode_func( data_out, data_out, ((T*)src) );
            src += stride;
            opcode_func( data_out, data_out, ((T*)src) );
            src += stride;
        }

        switch (remainder) {
            case 3:
                opcode_func( data_out, data_out, ((T*)src) );
                src += stride;
            case 2:
                opcode_func( data_out, data_out, ((T*)src) );
                src += stride;
            case 1:
                opcode_func( data_out, data_out, ((T*)src) );
                src += stride;
        }

    /*
    } else if (op_in->ndim == 2) {          // 2D General case

        Experiments show that the general case is almost as fast as
         an optimized 2D version
    */

    } else {                                    // ND general case

        bh_instruction instr;
        bh_error err;

        bh_view *tmp = &instr.operand[1];           // Copy the input-array meta-data
        tmp->base    = bh_base_array(op_in);
        tmp->ndim    = op_in->ndim-1;
        tmp->start   = op_in->start;
        for(j=0, i=0; i < op_in->ndim; ++i) {        // Copy every dimension except for the 'axis' dimension.
            if(i != axis) {
                tmp->shape[j]    = op_in->shape[i];
                tmp->stride[j]   = op_in->stride[i];
                ++j;
            }
        }

        instr.opcode = BH_IDENTITY;                 // Copy the first element to the output.
        instr.operand[0] = *op_out;
        bh_tstate state;
        bh_tstate_reset( &state, &instr );
        err = traverse_aa<T, T, identity_functor<T, T> >(&instr, &state);
        if (err != BH_SUCCESS) {
            return err;
        }

        bh_index stride = op_in->stride[axis];
        bh_index stride_bytes = stride * sizeof(T);

        instr.opcode = opcode;                // Reduce over the 'axis' dimension.
        instr.operand[0] = *op_out;           // NB: the first element is already handled.
        instr.operand[2] = *op_out;           // Note that operand[1] is still the tmp view

        tmp->start += stride;
        bh_tstate_reset( &state, &instr );

        void* out_start = state.start[0];
        void* tmp_start = state.start[1];

        for(i=1; i<nelements; ++i) {

            err = traverse_aaa<T, T, T, Instr>(&instr, &state);
            if (err != BH_SUCCESS) {
                return err;
            }

            tmp->start += stride;

            // Faster replacement of bh_tstate_reset
            tmp_start = (void*)(((char*)tmp_start) + stride_bytes);
            state.start[0] = out_start;
            state.start[1] = tmp_start;
            state.start[2] = out_start;
        }
    }
    return BH_SUCCESS;
}

bh_error bh_compute_reduce(bh_instruction *inst)
{
    if (inst->constant.type != BH_INT64)
        return BH_TYPE_NOT_SUPPORTED;

    bh_index axis = inst->constant.value.int64;
    bh_opcode opcode;
    bh_view *op_out = &inst->operand[0];
    bh_view *op_in  = &inst->operand[1];

    assert(op_out != NULL);

    switch (inst->opcode)
    {
        %set $lastopcode = ''
        %for $case in $data
        %if $case.opcode != $lastopcode
        case ${case.opcode}_REDUCE:
            opcode = ${case.opcode};
            break;
        %end if
        %set $lastopcode = $case.opcode
        %end for
        default:
            return BH_TYPE_NOT_SUPPORTED;
    }

                                                        //  Sanity checks.
    if (bh_operands(opcode) != 3) {
        fprintf(stderr, "ERR: opcode: %lld is not a binary ufunc, hence it is not suitable for reduction.\n", (long long int)opcode);
        return BH_ERROR;
    }

    if (bh_base_array(op_in)->data == NULL) {
        fprintf(stderr, "ERR: bh_compute_reduce; input-operand ( op_in ) is null.\n");
        return BH_ERROR;
    }

    if (op_in->base->type != op_out->base->type) {
        fprintf(stderr, "ERR: bh_compute_reduce; input and output types are mixed."
                        "Probable causes include reducing over 'LESS', just dont...\n");
        return BH_ERROR;
    }

    long int poly = opcode + (op_in->base->type << 8);

    switch(poly) {

        %for $case in $data
        case ${case.opcode} + (${case.op1} << 8):
            return bh_compute_reduce_any<${case.ftype}, ${case.fname}_functor<${case.ftype}, ${case.ftype}, ${case.ftype} > >( op_out, op_in, axis, opcode );
        %end for

        default:

            return BH_ERROR;

    }

}
